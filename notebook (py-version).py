# -*- coding: utf-8 -*-
"""notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YasiVxL894zAv0u_TGp4HAjLbnJjOzv5

# Pengembangan Sistem Rekomendasi Film Dengan Teknik Content-based Filtering

# Import Library
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.neighbors import NearestNeighbors
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

"""# Datasets Understanding

## Data Loading
"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("parasharmanas/movie-recommendation-system")
df = pd.read_csv(path + "/movies.csv")
df.info()

"""menggunakan library kagglehub langsung untuk mengambil dataset

Ada 62423 Baris data dalam datasets tersebut, dengan jumlah fitur sebanyak 3

# Analysis Variable
"""

df.info()

"""Dataset ini berisi judul film dan genre" nya"""

df.head()

unique_genres = [i for i in df["genres"].str.split("|").explode().unique() if i]
print(f"Unique genres: {len(unique_genres)}")
print(unique_genres)

"""Melakukan processing sederhana dengan cara menghilangkan "|" untuk melihat jumlah genre yang ada

terdapat 20 unique genre
"""

mask = df['genres'].str.contains('(no genres listed)')
df[mask]

"""Terdapat 5062 baris data dengan genre "no genres listed". Entri ini dikategorikan sebagai missing value karena content-based filtering memerlukan informasi genre. Karena genre tersebut tidak dapat diidentifikasi, baris data ini akan dihapus (drop). Mengingat volume data keseluruhan yang besar, penghapusan ini diperkirakan tidak akan berdampak signifikan."""

df = df[~mask]
df.shape

df.describe(include='all')

"""Karena data masih berupa object string, maka method describe tidak bisa memberikan gambaran statistik umum secara detail. perlu di lakukan preprocessing terlebih dahulu

# Handle Missing Value
"""

df.isnull().sum()

"""Tidak terdapat missing value dalam dataset ini

## Handle Duplicated Values
"""

df['title'].duplicated().sum()

"""Terdapat 83 judul film yang sama dalam dataset"""

df[df['title'].duplicated(keep=False)].sort_values('title')

"""Dari hasil filtering diatas, dapat dilihat bahwa terdapat beberapa film yang memiliki entri lebih dari 1 dengan genre dan id yang berbeda. Dalam studi kasus ini, data duplikat akan drop, dan hanya keep salah satu entri saja untuk menyederhanakan proses dan menghindari bias genre"""

df.drop_duplicates(subset='title', inplace=True)
df.shape

df[df['title'].duplicated(keep=False)].sort_values('title')

"""Data duplikat telah hilang

# Univariate Analysis
"""

genre_counts = df['genres'].str.split('|').explode().value_counts()

plt.figure(figsize=(12, 6))
sns.barplot(x=genre_counts.index, y=genre_counts.values, palette='viridis')
plt.xticks(rotation=45, ha='right')
plt.title('Number of Movies per Genre')
plt.xlabel('Genre')
plt.ylabel('Count')
plt.tight_layout()
plt.show()

"""Menganalisis jumlah kemunculan genre per film. Dapat dilihat genre "Drama" menjadi genre yang paling banyak ada di data film tersebut

# Data Preparation

## Memisahkan String Genre menjadi Daftar (List)
"""

# Membuat kolom baru berisi daftar genre
df['genres_list'] = df['genres'].str.split('|')

print("\nDataset dengan Kolom 'genres_list':")
df

"""Kolom genres saat ini berisi satu string panjang yang dipisahkan oleh pipa (|). Kita perlu mengubahnya menjadi daftar (list) dari setiap genre.

## Encoding Genre

Ini adalah langkah paling penting. Kita perlu mengubah daftar genre menjadi representasi numerik. Metode yang cocok dalam format data seperti ini yaitu menggunakan MultiLabelBinarizer dari Scikit-learn, yang secara efektif melakukan hal serupa untuk data multi-label.
"""

mlb = MultiLabelBinarizer()

# Terapkan MultiLabelBinarizer ke kolom 'genres_list'
genre_encoded = pd.DataFrame(
    mlb.fit_transform(df['genres_list']),
    columns=mlb.classes_,
    index=df.index
)

print("\nGenre yang Sudah di-Encode (One-Hot Encoded):")
genre_encoded.head()

df_processed = pd.concat([df[['movieId', 'title']], genre_encoded], axis=1)

print("\nDataset Final yang Siap untuk Content-Based Filtering:")
df_processed

"""Output hasil encoding diatas merupakan representasi fitur penting dari setiap genre dengan menggunakan multilabel binarizer. Setiap genre unik akan menjadi sebuah kolom baru. Untuk setiap film, kolom genre tersebut akan bernilai 1 jika film tersebut memiliki genre itu, dan 0 jika tidak.

# Modelling

Pemilihan Algoritma

Pendekatan yang dipilih adalah sebagai berikut:

- Nearest Neighbors:

    - Sederhana & Intuitif: Mudah dipahami dan diimplementasikan.
    - Efektif Mencari Kemiripan: Bagus untuk menemukan item serupa atau melakukan rekomendasi.
    - Fleksibel: Tidak memerlukan asumsi kuat tentang distribusi data.

- Cosine Similarity on-demand:

    - Hemat Memori & Komputasi: Menghindari pembuatan matriks similaritas besar yang boros memori, dihitung hanya saat perlu. Ini penting - untuk   skalabilitas, terutama pada dataset besar.
    - Cocok untuk Data Jarang & Dimensi Tinggi: Efektif untuk data seperti teks atau interaksi pengguna-item, di mana banyak nilai adalah nol.

## Nearest Neighbors
"""

nn_model = NearestNeighbors(n_neighbors=11, metric='euclidean', algorithm='ball_tree')
nn_model.fit(genre_encoded.values)

"""### Inference"""

def get_recommendations_with_nn(movie_index, nn_model_trained, movie_titles_list, movie_genre_list, all_movie_features, top_n=10):
    if movie_index >= len(all_movie_features):
        print("Indeks film tidak valid.")
        return pd.DataFrame()

    target_movie_vector = all_movie_features[movie_index].reshape(1, -1)
    distances, indices = nn_model_trained.kneighbors(target_movie_vector,n_neighbors=top_n+1)

    recs = []
    for i in range(1, len(indices[0])):
        neighbor_index = indices[0][i]
        similarity_score = 1 - distances[0][i]
        recs.append({
            'title': movie_titles_list[neighbor_index],
            'genres': movie_genre_list[neighbor_index],
            'similarity_score': similarity_score,
            'distance': distances[0][i]
        })
    print(f"Rekomendasi untuk film: {movie_titles_list[movie_index]} {movie_genre_list[movie_index]}")
    return pd.DataFrame(recs)

movie_titles = df['title'].values
movie_genres = df['genres_list'].values

recommendations_df = get_recommendations_with_nn(0, nn_model, movie_titles, movie_genres, genre_encoded.values)
recommendations_df

"""Dalam algoritma Nearest Neighbors, digunakan metrik Euclidean sebagai pengukur kemiripan antar film berdasarkan representasi genre yang telah di-encode. Algoritma `ball_tree` dipilih karena efisien untuk data berdimensi tinggi dan dapat mempercepat proses pencarian tetangga terdekat pada dataset yang besar. Dengan pendekatan ini, sistem dapat merekomendasikan film-film yang memiliki kemiripan genre secara optimal dan efisien.

## Cosine Similarity On-Demand
"""

def get_recommendations_on_demand(movie_index, all_movie_features, movie_titles_list, movie_genre_list, top_n=10):
    if movie_index >= len(all_movie_features):
        print("Indeks film tidak valid.")
        return pd.DataFrame()

    target_movie_vector = all_movie_features[movie_index].reshape(1, -1)
    similarity_scores = cosine_similarity(target_movie_vector, all_movie_features)
    similarity_scores_for_target = similarity_scores[0]

    movie_similarity_pairs = list(enumerate(similarity_scores_for_target))
    sorted_similar_movies = sorted(movie_similarity_pairs, key=lambda x: x[1], reverse=True)

    recs = []
    for i, score in sorted_similar_movies:
        if i == movie_index:
            continue
        if len(recs) < top_n:
            recs.append({
                'title': movie_titles_list[i],
                'genres': movie_genre_list[i],
                'similarity_score': score
            })
        else:
            break

    print(f"Rekomendasi untuk film: {movie_titles_list[movie_index]} {movie_genre_list[movie_index]}")
    return pd.DataFrame(recs)

get_recommendations_on_demand(0, genre_encoded.values, movie_titles, movie_genres)

"""Pada algoritma cosine similarity on demand, perhitungan cosine similarity dilakukan saat proses inference, yaitu dengan membandingkan film yang dicari terhadap seluruh film yang ada. Sistem kemudian mengembalikan daftar film dengan tingkat kemiripan tertinggi berdasarkan genre dengan film yang dicari.

# Evaluation

# Precision

## Penjelasan Metric Precision pada Sistem Rekomendasi

**Precision** dalam sistem rekomendasi mengukur seberapa relevan item yang direkomendasikan terhadap kebutuhan pengguna. Dalam konteks sistem rekomendasi film berbasis genre seperti pada notebook ini, precision dihitung sebagai proporsi film yang direkomendasikan yang benar-benar memiliki genre target (misal: "Comedy") dari seluruh film yang direkomendasikan.


Precision penting untuk menilai kualitas rekomendasi: semakin tinggi precision, semakin banyak rekomendasi yang benar-benar sesuai dengan preferensi pengguna (genre yang dicari)
"""

def calculate_precision(
    index_movie: int,
    df_recommendations: pd.DataFrame,
    n: int = 10
) -> float:
    """
    Menghitung Precision@N berdasarkan apakah film yang direkomendasikan
    memiliki setidaknya satu genre yang sama dengan film input (berdasarkan index).
    """
    if df_recommendations.empty or n == 0:
        return 0.0

    # Ambil set genre dari df berdasarkan index_movie
    input_genres = set(df.iloc[index_movie]['genres_list'])
    if not input_genres:
        return 0.0

    num_to_check = min(n, len(df_recommendations))
    relevant = 0

    for i in range(num_to_check):
        rec_genres = set(df_recommendations.iloc[i]['genres'])
        if input_genres & rec_genres:
            relevant += 1

    print(f"Precision@{n} untuk film {df.iloc[index_movie]['title']}: {relevant}/{num_to_check}")

nn_recommendations = get_recommendations_with_nn(0, nn_model, movie_titles, movie_genres, genre_encoded.values)
calculate_precision(0, nn_recommendations, n=10)

cosine_recommendations = get_recommendations_on_demand(0, genre_encoded.values, movie_titles, movie_genres)
calculate_precision(0, cosine_recommendations, n=10)

"""### Hasil Evaluasi Precision

Berdasarkan hasil evaluasi precision pada sistem rekomendasi film berbasis content-based filtering di atas, diperoleh nilai **Precision@10 = 1.0** untuk kedua metode (Nearest Neighbors dan Cosine Similarity). Artinya, dari 10 film yang direkomendasikan untuk film input (misal: "Toy Story (1995)"), seluruh film yang direkomendasikan memiliki setidaknya satu genre yang sama dengan film input tersebut.

Nilai precision yang tinggi ini menunjukkan bahwa sistem rekomendasi mampu memberikan rekomendasi yang sangat relevan secara genre. Dengan kata lain, setiap film yang direkomendasikan memang sesuai dengan preferensi genre dari film yang dicari, sehingga sistem efektif dalam menyaring film yang benar-benar mirip dari sisi konten (genre).

Namun, perlu diingat bahwa precision hanya mengukur relevansi genre, bukan kualitas keseluruhan rekomendasi (misal: popularitas, rating, atau faktor lain di luar genre). Precision yang tinggi sangat penting untuk memastikan pengguna mendapatkan rekomendasi yang sesuai dengan minat awalnya.
"""